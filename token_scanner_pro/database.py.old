"""
Module de gestion de la base de données
Utilisateurs et Favoris - Thread-Safe
"""

import sqlite3
import json
from datetime import datetime
from typing import Optional, List, Dict, Any
from flask_bcrypt import Bcrypt
import threading

bcrypt = Bcrypt()

class Database:
    def __init__(self, db_path: str = "token_scanner.db"):
        self.db_path = db_path
        self._local = threading.local()
        self.init_db()
    
    def get_connection(self):
        """Crée une connexion thread-safe à la base de données"""
        if not hasattr(self._local, 'conn') or self._local.conn is None:
            self._local.conn = sqlite3.connect(
                self.db_path, 
                check_same_thread=False,
                timeout=30.0,  # Timeout de 30 secondes
                isolation_level=None  # Autocommit mode
            )
            self._local.conn.row_factory = sqlite3.Row
            # Activer WAL mode pour meilleures performances
            self._local.conn.execute('PRAGMA journal_mode=WAL')
        return self._local.conn
    
    def init_db(self):
        """Initialise la base de données avec les tables nécessaires"""
        conn = sqlite3.connect(self.db_path)
        conn.execute('PRAGMA journal_mode=WAL')
        cursor = conn.cursor()
        
        # Table utilisateurs
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                email TEXT UNIQUE NOT NULL,
                username TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                is_premium BOOLEAN DEFAULT 0,
                scan_count INTEGER DEFAULT 0,
                last_scan TIMESTAMP
            )
        """)
        
        # Table favoris
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS favorites (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token_address TEXT NOT NULL,
                token_chain TEXT NOT NULL,
                token_data TEXT,
                notes TEXT,
                added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id),
                UNIQUE(user_id, token_address, token_chain)
            )
        """)
        
        # Table historique des scans
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS scan_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                scan_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                tokens_scanned INTEGER,
                safe_count INTEGER,
                danger_count INTEGER,
                results TEXT,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        """)
        
        conn.commit()
        conn.close()
    
    # ==================== GESTION UTILISATEURS ====================
    
    def create_user(self, email: str, username: str, password: str) -> Optional[int]:
        """Crée un nouveau utilisateur"""
        try:
            password_hash = bcrypt.generate_password_hash(password).decode('utf-8')
            
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("BEGIN")
            cursor.execute("""
                INSERT INTO users (email, username, password_hash)
                VALUES (?, ?, ?)
            """, (email, username, password_hash))
            
            user_id = cursor.lastrowid
            cursor.execute("COMMIT")
            
            return user_id
        except sqlite3.IntegrityError:
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return None
        except Exception as e:
            print(f"Erreur create_user: {e}")
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return None
    
    def get_user_by_email(self, email: str) -> Optional[Dict]:
        """Récupère un utilisateur par email"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
        except Exception as e:
            print(f"Erreur get_user_by_email: {e}")
            return None
    
    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """Récupère un utilisateur par ID"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
        except Exception as e:
            print(f"Erreur get_user_by_id: {e}")
            return None
    
    def verify_password(self, email: str, password: str) -> Optional[Dict]:
        """Vérifie les identifiants et retourne l'utilisateur"""
        user = self.get_user_by_email(email)
        
        if user and bcrypt.check_password_hash(user['password_hash'], password):
            return user
        return None
    
    def update_scan_count(self, user_id: int):
        """Incrémente le compteur de scans"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("BEGIN")
            cursor.execute("""
                UPDATE users 
                SET scan_count = scan_count + 1, 
                    last_scan = CURRENT_TIMESTAMP
                WHERE id = ?
            """, (user_id,))
            cursor.execute("COMMIT")
        except Exception as e:
            print(f"Erreur update_scan_count: {e}")
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
    
    def get_user_stats(self, user_id: int) -> Dict[str, Any]:
        """Récupère les statistiques d'un utilisateur"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            # Stats utilisateur
            cursor.execute("""
                SELECT scan_count, created_at, last_scan, is_premium
                FROM users WHERE id = ?
            """, (user_id,))
            user_stats = dict(cursor.fetchone() or {})
            
            # Nombre de favoris
            cursor.execute("""
                SELECT COUNT(*) as favorite_count
                FROM favorites WHERE user_id = ?
            """, (user_id,))
            result = cursor.fetchone()
            user_stats['favorite_count'] = result['favorite_count'] if result else 0
            
            # Historique des scans
            cursor.execute("""
                SELECT COUNT(*) as history_count,
                       COALESCE(SUM(tokens_scanned), 0) as total_tokens_scanned
                FROM scan_history WHERE user_id = ?
            """, (user_id,))
            history = dict(cursor.fetchone() or {})
            user_stats.update(history)
            
            return user_stats
        except Exception as e:
            print(f"Erreur get_user_stats: {e}")
            return {}
    
    # ==================== GESTION FAVORIS ====================
    
    def add_favorite(self, user_id: int, token_address: str, token_chain: str, 
                     token_data: Dict, notes: str = "") -> bool:
        """Ajoute un token aux favoris"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("BEGIN")
            cursor.execute("""
                INSERT INTO favorites (user_id, token_address, token_chain, token_data, notes)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, token_address, token_chain, json.dumps(token_data), notes))
            cursor.execute("COMMIT")
            
            return True
        except sqlite3.IntegrityError:
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return False
        except Exception as e:
            print(f"Erreur add_favorite: {e}")
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return False
    
    def remove_favorite(self, user_id: int, token_address: str, token_chain: str) -> bool:
        """Retire un token des favoris"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("BEGIN")
            cursor.execute("""
                DELETE FROM favorites 
                WHERE user_id = ? AND token_address = ? AND token_chain = ?
            """, (user_id, token_address, token_chain))
            
            deleted = cursor.rowcount > 0
            cursor.execute("COMMIT")
            
            return deleted
        except Exception as e:
            print(f"Erreur remove_favorite: {e}")
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return False
    
    def get_user_favorites(self, user_id: int) -> List[Dict]:
        """Récupère tous les favoris d'un utilisateur"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT * FROM favorites 
                WHERE user_id = ?
                ORDER BY added_at DESC
            """, (user_id,))
            
            rows = cursor.fetchall()
            
            favorites = []
            for row in rows:
                fav = dict(row)
                try:
                    fav['token_data'] = json.loads(fav['token_data'])
                except:
                    fav['token_data'] = {}
                favorites.append(fav)
            
            return favorites
        except Exception as e:
            print(f"Erreur get_user_favorites: {e}")
            return []
    
    def is_favorite(self, user_id: int, token_address: str, token_chain: str) -> bool:
        """Vérifie si un token est dans les favoris"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT COUNT(*) as count FROM favorites 
                WHERE user_id = ? AND token_address = ? AND token_chain = ?
            """, (user_id, token_address, token_chain))
            
            result = cursor.fetchone()
            count = result['count'] if result else 0
            
            return count > 0
        except Exception as e:
            print(f"Erreur is_favorite: {e}")
            return False
    
    def update_favorite_notes(self, user_id: int, token_address: str, 
                             token_chain: str, notes: str) -> bool:
        """Met à jour les notes d'un favori"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("BEGIN")
            cursor.execute("""
                UPDATE favorites 
                SET notes = ?
                WHERE user_id = ? AND token_address = ? AND token_chain = ?
            """, (notes, user_id, token_address, token_chain))
            
            updated = cursor.rowcount > 0
            cursor.execute("COMMIT")
            
            return updated
        except Exception as e:
            print(f"Erreur update_favorite_notes: {e}")
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return False
    
    # ==================== HISTORIQUE DES SCANS ====================
    
    def save_scan_history(self, user_id: int, scan_results: Dict) -> int:
        """Sauvegarde l'historique d'un scan"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("BEGIN")
            cursor.execute("""
                INSERT INTO scan_history 
                (user_id, tokens_scanned, safe_count, danger_count, results)
                VALUES (?, ?, ?, ?, ?)
            """, (
                user_id,
                scan_results.get('total_analyzed', 0),
                scan_results.get('safe_count', 0),
                scan_results.get('dangerous_count', 0),
                json.dumps(scan_results.get('results', []))
            ))
            
            history_id = cursor.lastrowid
            cursor.execute("COMMIT")
            
            return history_id
        except Exception as e:
            print(f"Erreur save_scan_history: {e}")
            try:
                cursor.execute("ROLLBACK")
            except:
                pass
            return 0
    
    def get_scan_history(self, user_id: int, limit: int = 10) -> List[Dict]:
        """Récupère l'historique des scans d'un utilisateur"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, scan_date, tokens_scanned, safe_count, danger_count
                FROM scan_history 
                WHERE user_id = ?
                ORDER BY scan_date DESC
                LIMIT ?
            """, (user_id, limit))
            
            rows = cursor.fetchall()
            
            return [dict(row) for row in rows]
        except Exception as e:
            print(f"Erreur get_scan_history: {e}")
            return []
    
    def get_scan_details(self, scan_id: int) -> Optional[Dict]:
        """Récupère les détails complets d'un scan"""
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT * FROM scan_history WHERE id = ?
            """, (scan_id,))
            
            row = cursor.fetchone()
            
            if row:
                scan = dict(row)
                try:
                    scan['results'] = json.loads(scan['results'])
                except:
                    scan['results'] = []
                return scan
            return None
        except Exception as e:
            print(f"Erreur get_scan_details: {e}")
            return None
